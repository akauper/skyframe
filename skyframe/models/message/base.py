import textwrap
from typing import Optional, Dict, Any, TypeVar, List

from pydantic import Field, PrivateAttr, computed_field

from .chunk import MessageChunk
from .role import MessageRole
from ..base import UIDMixin, CreatedAtMixin


class Message(UIDMixin, CreatedAtMixin):
    """
    A Message generated by an Agent or a User in a Conversation.

    Message differs from TextResponse in specificity; it was ALWAYS generated from an Agent or a User.
    TextResponse is a generic response generated from any LLM service and has a lot of additional information
    about the generation process.
    """
    role: MessageRole = Field(default=MessageRole.user)
    """ The role of the message. """

    _content: str = PrivateAttr(default='')
    """ The message content. """

    author_id: Optional[str] = Field(default=None)
    """ The ID of the author of the message. """

    author_name: Optional[str] = Field(default=None)
    """ The name of the author of the message. """

    scenario_instance_id: Optional[str] = Field(default=None)
    """ The scenario instance ID of the message. """

    audio_id: Optional[str] = Field(default=None)
    """ The uid of the MessageAudio that was generated from this message (if any). """

    metadata: Dict[str, Any] = Field(default_factory=dict)
    """ Additional metadata about the message. """

    def serializable_copy(self) -> 'Message':
        return Message(
            id=self.id,
            created_at=self.created_at,
            role=self.role,
            content=self.content,
            author_id=self.author_id,
            author_name=self.author_name,
            scenario_instance_id=self.scenario_instance_id,
            audio_id=self.audio_id,
            metadata=self.metadata,
        )

    @computed_field
    @property
    def content(self) -> str:
        return self._content

    @content.setter
    def content(self, value: str) -> None:
        self._content = value

    def __init__(self, **data: Any):
        super().__init__(**data)
        self._content = data.get('content', '')

    @property
    def prefix(self) -> str:
        if self.role == MessageRole.system:
            return 'System'
        elif self.role == MessageRole.user:
            return self.author_name or 'User'
        elif self.role == MessageRole.ai:
            return self.author_name or 'Assistant'
        elif self.role == MessageRole.summary:
            return 'Summary of the conversation leading up to this point'
        else:
            return ''

    def __iadd__(self, chunk: 'MessageChunk') -> 'Message':
        self.content += chunk.content
        return self

    def to_string(self) -> str:
        string = f'{self.prefix}: {self.content}'
        return string

    @staticmethod
    def join_as_string(messages: List['Message'], omit_system_messages: bool = False) -> str:
        messages_str = ''
        for message in messages:
            if omit_system_messages and message.is_from(MessageRole.system):
                continue
            messages_str += f'{message.to_string()}\n'
        return messages_str

    def __pretty__(self, fmt: Any, **kwargs: Any) -> Any:
        yield 'Message:'
        yield 1
        yield f'ID: {self.id}  Created At: {self.created_at}  Scenario Instance ID: {self.scenario_instance_id}'
        yield 0
        yield f'Role: {self.role}'
        yield 0
        yield f'Author ID: {self.author_id}'
        yield 0
        yield f'Author Name: {self.author_name}'
        yield 0
        yield f'Audio ID: {self.audio_id}'
        yield 0
        yield f'Metadata: {self.metadata}'
        yield 0
        yield f'Content:'
        yield 1
        preprocessed_content = self.content.replace('\t', '    ')
        lines = preprocessed_content.split('\n')
        for line in lines:
            yield textwrap.fill(f"{line}", width=120, initial_indent='', subsequent_indent='\t\t\t\t\t\t')
            yield 0

    def pretty_print(self) -> None:
        preprocessed_content = self.content.replace('\t', '    ')
        lines = preprocessed_content.split('\n')

        print(f'Message(id={self.id}, created_at={self.created_at}, role={self.role}, author_id={self.author_id}, author_name={self.author_name}, scenario_instance_id={self.scenario_instance_id}, audio_id={self.audio_id}, metadata={self.metadata})')
        for line in lines:
            print(line)

    def is_from(self, role: MessageRole) -> bool:
        return self.role == role

    @property
    def to_mentor(self) -> bool:
        return self.metadata.get('to_mentor', False)

    @classmethod
    def from_system(
            cls,
            content: str,
            *,
            author_id: Optional[str] = None,
            author_name: Optional[str] = None,
            scenario_instance_id: Optional[str] = None,
            **metadata: Any
    ) -> 'Message':
        return cls(
            role=MessageRole.system,
            content=content,
            scenario_instance_id=scenario_instance_id,
            metadata=metadata,
        )

    @classmethod
    def from_user(
            cls,
            content: str,
            *,
            author_id: Optional[str] = None,
            author_name: Optional[str] = None,
            scenario_instance_id: Optional[str] = None,
            **metadata: Any
    ) -> 'Message':
        return cls(
            role=MessageRole.user,
            content=content,
            author_id=author_id,
            author_name=author_name,
            scenario_instance_id=scenario_instance_id,
            metadata=metadata,
        )

    @classmethod
    def from_ai(
            cls,
            content: str,
            *,
            author_id: Optional[str] = None,
            author_name: Optional[str] = None,
            scenario_instance_id: Optional[str] = None,
            **metadata: Any
    ) -> 'Message':
        return cls(
            role=MessageRole.ai,
            content=content,
            author_id=author_id,
            author_name=author_name,
            scenario_instance_id=scenario_instance_id,
            metadata=metadata,
        )

    @classmethod
    def from_summary(
            cls,
            content: str,
            *,
            scenario_instance_id: Optional[str] = None,
            **metadata: Any
    ) -> 'Message':
        return cls(
            role=MessageRole.summary,
            content=content,
            scenario_instance_id=scenario_instance_id,
            metadata=metadata,
        )


TMessage = TypeVar('TMessage', bound=Message)
